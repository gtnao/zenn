---
title: "自作DBMSに必要な体系的トランザクション知識（導入・Isolation編）"
emoji: "🐘"
type: "tech"
topics: ["database", "db", "rdbms", "transaction"]
published: false
publication_name: "primenumber"
---

# はじめに

本記事は、**自作DBMS**を趣味とする筆者が、トランザクション周りの実装を進めるにあたって、自身の中で腹落ちさせるために調べた内容を記事化したものです。
そういった動機が故に、多少長いですが、**頭から読み進めていくこと**で、（この記事に辿り着く方であればご存知の基礎的な話を除いて、）自然な思考の流れで理解が進むように心がけたつもりではあります。

人類が生み出したソフトウェアの叡智の結晶の1つであるDBMS、その根幹に鎮座する**トランザクション理論**は、ユーザー視点での「あって当たり前」という感覚とは裏腹に、様々な概念や歴史的な背景が入り乱れ、全体像を把握することは大変困難です。
従って、本記事に至っても、筆者の理解不足が含まれている可能性はあり、その際はお手柔らかにご指摘ください。

ちなみに、自作と名を打ってますが、ソースコードは一切登場しません。

# トランザクションとは

データベースにおけるトランザクションとは、一言で言うと**一連の読み書き操作をまとめたもの**です。
耳タコな例の銀行の送金処理については今更説明しませんが、一連の操作が**全て成功するか、全て失敗するか**のどちらかであることが求められるケースは現実的にも多く、これがトランザクションという概念が必要になる基本的な動機です。

ただし、具体的にどのような操作をまとめるかはアプリケーション側の責務であり、DBMS側はそれらがビジネスロジック上どのような意味を持つかには関与しません。
DBMSはあくまで、一般的なトランザクションというまとまりに対して要求されるいくつかの抽象的な特性を保証することを責務とします。

# ACID

トランザクションが保証すべき性質として、**ACID**特性が広く知られています。
その概要は今更解説する必要はないかもしれませんが、幾分注意が必要です。

- **Atomicity** （原子性）
- **Consistency** （一貫性）
- **Isolation** （独立性/隔離性）
- **Durability** （永続性）

特にイケてないのはConsistencyです。
これは例えば、「口座残高がマイナスにならない」、「ユーザーIDは重複しない」といった、ビジネスロジックの整合性を保証する性質とされていますが、具体的にどういった整合性を要求するかはアプリケーション側の責務です。
DBMSの提供する型システムや制約はConsistencyを間接的に支援するかもしれませんが、汎用的なトランザクション処理からしたらその具体は知ったこっちゃないわけです。
かの有名な『データ指向アプリケーションデザイン』でも

> ACIDはほとんどマーケティング用語

> 特にConcistencyはACIDに含まれない

などと、散々に言われてしまっています。

残りの**Atomicity**、**Isolation**、**Durability**は、DBMS側が保証すべき特性です。
これらはもちろん相互に関連し合っているものの、各々どういった保証でどういった理論の元で成り立っているのかを**分解して考える**ことで、トランザクション理論の全体像を捉えやすくなると筆者は考えています。

## Atomicity （原始性）

**Atomicity**は、前述の**全て成功するか全て失敗するか**を保証する性質です。
もしトランザクションが完了できなかった場合（Abort）、トランザクション開始前の状態にデータベースを戻す必要があります。

実現方法としては、トランザクション中に行った変更操作を記録しておき、Abort時にそれらを逆順に実行して元に戻す、という方法が考えられます。
Durabilityを考える（ディスクに未書き込みなCommitすべき操作や、書き込み済みのAbortすべき操作が存在）ともう少しややこしくなるのですが、本記事ではこの程度に留めておきます。

注意点は、Atomicity自体は**単一のトランザクション内で完結**する性質であり、複数のトランザクションが同時に実行される状況を直接扱うものではありません。
それはIsolationの役割です。
やはり分けて捉えることが重要です。

## Durability （永続性）

**Durability**は、ひとたびCommitされたトランザクションによる変更は、後に**障害などが発生しても失われない**ことを保証する性質です。
もちろん、隕石が落ちてきたらどうしようもないので、トランザクション文脈では、変更内容が不揮発性ストレージ（ディスクやSSDなど）に何らかの形で記録された時点でDurabilityが保証されるとして考えることが多いはずです（単一DBの場合）。

最も単純な実現方法は、Commitされるたびにその内容をディスクに書き込むことに思われます。
しかし、ディスクアクセスはメモリアクセスに比べてすこぶる低速なため、現実的ではないのは見るも明らかです。
そのため、現実のDBMSでは、メモリ（バッファプール）上でデータの読み書きを行いますが、揮発性メモリを使うトレードオフとして**復旧のためのアルゴリズム**が要求されます。
**WAL（Write-Ahead Log）**や**ARIES**という仕組み・アルゴリズムが典型的ですが、本記事では次のIsolationに焦点を当てるため、こちらもこの程度に留めておきます。

## Isolation （独立性/隔離性）

**Isolation**は、**複数のトランザクションが同時に実行される状況において互いに影響を与えない**ことを保証する性質です。

DBMS側で制御し、同時に実行されているトランザクションが常に一つになるように他のトランザクションを待たせておけば（**逐次実行**と言う）、少なくともIsolationの問題は発生しませんが、これまたパフォーマンス上現実的ではないことは明白です。

そこで、通常は複数のトランザクションを並行（Concurrent）に実行し、各トランザクションの個々の操作は時系列的に入り混じることになります。
しかし、デタラメでいいはずもないので、**どのような順序なら許容範囲**なのか、**部分的に許容される**のか、ということが今後の話のテーマとなります。

# Serializability

## 題材

今後の話を進めるにあたって、例があった方が分かりやすいので、ある2つのトランザクションを考えます。

$$
\begin{aligned}
T_{1} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle\\[4pt]
T_{2} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

- $R_i(X)$はトランザクション$T_i$がデータ項目$X$を読み取る（Read）操作
- $W_i(X)$は同じく$T_i$が$X$に書き込む（Write）操作
- 添字$i$はその操作を実行するトランザクション番号,括弧内の$X$は対象データ項目

![](/images/dbms-isolation/tx001.png)
![](/images/dbms-isolation/tx002.png)

## スケジュール

あるトランザクションの集合に対して、それらに含まれる全ての操作の集合を（各トランザクション内での順序を保ったまま）並び替えた列をスケジュールと定義します。

題材のトランザクション集合だと、以下のような並行スケジュールが考えられます。
（これ以外にも沢山あります。）

$$
\begin{aligned}
S'  &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{2}(Y),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle \\[4pt]
\end{aligned}
$$

![](/images/dbms-isolation/tx003.png)

---

$$
\begin{aligned}
S'' &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

![](/images/dbms-isolation/tx004.png)

逐次実行の場合は、それぞれ以下のようになります。

$$
\begin{aligned}
S_{1,2} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; R_{2}(X),\; W_{2}(Y) \bigr\rangle \\[4pt]
\end{aligned}
$$

![](/images/dbms-isolation/tx005.png)

---

$$
\begin{aligned}
S_{2,1} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

![](/images/dbms-isolation/tx006.png)

ある並行実行のスケジュールが与えられたとき、「**何らかの基準においては**、少なくともいずれか一つの逐次実行のスケジュールと等価」と言える基準があるとします。
その場合、**その基準の枠内においては**、その並行実行は、**Isolationが部分的に保証**されていると考えることができそうです。

ここは、少し展開が飛躍してしまいますが、広く用いられている**Conflict Serializability**という基準について考えていきます。

## Conflict Serializability

**Conflict Serializability**は、**競合する操作の処理順序**に注目する考え方です。

### Conflict

まず、**Conflict**（競合）する操作、を定義します。
以下の3つの条件を全て満たす場合、異なる2つのトランザクション$T_i$と$T_j$にそれぞれ属する操作$op_i$と$op_j$はConflictすると考えます。

1.  $T_i \neq T_j$ （異なるトランザクションである）
2.  $op_i$ と $op_j$ が同じデータ項目にアクセスする
3.  $op_i$ と $op_j$ の少なくとも一方がWrite操作である

具体的には、以下のペアがConflictします（$X$は同じデータ項目）。

- $R_i(X)$ と $W_j(X)$ （Read-Write Conflict）
- $W_i(X)$ と $R_j(X)$ （Write-Read Conflict）
- $W_i(X)$ と $W_j(X)$ （Write-Write Conflict）

Read操作同士、$R_i(X)$ と $R_j(X)$は、Conflictしません。

ちなみに、Conflictする操作のペアが存在すること自体が即座に問題なわけではなく、またこの時点では順序関係はなく**ただのペア関係**という点を念頭においてください。

先ほどから用いている題材の場合は、以下の二つのConflictが存在します。

$$
\bigl\{\, \{W_{1}(X),\,R_{2}(X)\},\; \{W_{1}(Y),\,W_{2}(Y)\} \,\bigr\}
$$

![](/images/dbms-isolation/tx007.png)

### Conflict Equivalence

あるスケジュールが与えられると、先ほどの定義で導出したConflictする操作のペア群に順序関係が生まれます。

例として、先ほどの$S'$スケジュールを考えてみます。

$$
\begin{aligned}
S'  &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{2}(Y),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

こちらのスケジュールでは、Conflictする操作のペアは以下のような順序関係となります。

$$
\bigl\{\, (R_{2}(X) \;\to\; W_{1}(X)),\; (W_{2}(Y) \;\to\; W_{1}(Y)) \,\bigr\}
$$

![](/images/dbms-isolation/tx008.png)

そして、以下の$T_{2}$, $T_{1}$の順序で逐次実行したスケジュールに関するConflictの順序関係も同様となります。

$$
\begin{aligned}
S_{2,1} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

![](/images/dbms-isolation/tx009.png)

ある異なるスケジュール間のConflictの順序関係が全て一致する場合、それらのスケジュールは**Conflict Equivalent**であると言えます。
さらに、あるスケジュールがいずれかの逐次実行のスケジュールとConflict Equivalentである場合、そのスケジュールは**Conflict Serializable**と言うことができます。

### Conflict Serializableではない例

先ほどの例における$S'$はConflict Serializableを満たしましたが、$S''$はそうとは限りません。

$$
\begin{aligned}
S'' &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

Conflictの順序を考えると以下のようになります。

$$
\bigl\{\, (R_{2}(X) \;\to\; W_{1}(X)),\; (W_{1}(Y) \;\to\; W_{2}(Y)) \,\bigr\}
$$

![](/images/dbms-isolation/tx010.png)

こちらを属するトランザクション間の順序に当てはめると、以下のようになります。

$$
T_{2} \;\rightarrow\; T_{1}, \qquad
T_{1} \;\rightarrow\; T_{2}
$$

ある$T_{1}$に属する操作はある$T_{2}$に属する操作より前に行われるが、別の$T_{1}$に属する操作はある$T_{2}$に属する操作より後に行われるということになります。
これを満たす逐次実行のConflict順序が存在しないことも直感的に想像が着くと思います。

# 実装方法

ここまでで、ある並行実行が許容されるか否かの判断軸（Conflict Serializability）を手に入れましたが、その許容される並行実行を実現するにはどうすればいいでしょうか。
現実のDBMSでは、トランザクションはリアルタイムに流れ込み、完了（Commit/Abort）されるまでどのような操作が行われるかも分かりません。
そうなると、「あとから見ればConflict Serializableだった」という結果を、**実行中から保証**するための仕組みが必要になってきます。

そこで登場するのがロック機構、古典的な**Two-Phase Lock**（2PL）です。
またまた展開が飛躍してしまいますが、2PLに従った結果得られるスケジュールは必ずConflict Serializableになる、という定理が知られています。

## Shared/Exclusive Lock

まずロックの基本形を確認します。

|                      | Shared Lockを保持中 | Exclusive Lockを保持中 |
| -------------------- | ------------------- | ---------------------- |
| Shared Lockを取得    | OK（取得可）        | NG（待機）             |
| Exclusive Lockを取得 | NG（待機）          | NG（待機）             |

- **Shared Lock**（共有ロック）: 読み取り時に取得。互いに共有可。
- **Exclusive Lock**（排他ロック）: 書き込み時に取得。他のロックと競合。
- 競合した場合は、ロックが解放されるまで待機する。

この辺りは馴染みもあるかと思います。Conflictの定義とも似ていますね。

## Two Phase Lock

2PLはロックの**取得・解放を二段階の順序**で行われるようにさらに厳格にします。
簡単に言えば、ロックを**解放し始めたら取得してはいけないと**いう制約です。

1. **Growing Phase**（成長期）: ロックを取得してよい（解放は禁止）
2. **Shrinking Phase**（縮小期）: ロックを解放してよい（取得は禁止）

横軸を時間軸、縦軸を一つのトランザクションにおけるロックの取得件数とすると以下のようになります。

![](/images/dbms-isolation/tx011.png)

### 証明

「2PL に従った結果得られるスケジュールは必ずConflict Serializableになる」という命題は背理法で証明できます。

1. 2PL を守るトランザクション集合のスケジュール $S$ が **Conflict Serializable でない**  
   と仮定する。
2. 非 Serializable なら **トランザクション競合グラフ** にサイクルが存在する。
3. サイクルの 2 頂点 $(T_i,T_j)$ を結ぶ辺は、あるデータ項目 $X$ について  
   $T_i$ が先にロックを取得し解放、次に $T_j$ がロックを取得したことを示す。
4. 逆向きの辺では $T_j$ が先にロックを取得し解放、あとで $T_i$ が取得している。
5. すると $T_i$ は **解放後に再びロックを取得** したことになり、  
   2PL の「縮小期に取得禁止」に違反して矛盾する。

といった要領です。

### Deadlock

2PLは厳格なロック制御のおかげで整合性は保てるものの、その分**デッドロックが発生しやすい**という弱点があります。
デッドロック自体の説明はよく聞くと思うので割愛しますが、 潜在的に起こる以上は検知の仕組みと発生時の対応の決めが必要です。
それに関しても本稿では省略します。

# Cascading Abort

2PLを課せば、ある基準においてはIsolation特性を許容できる並行実行制御を実現できそうです。
しかし、ここまでの話では、トランザクションが**Abortされることを考えていません**でした。
ACID特性のIsolationだけに着目しており、Atomicity/Durabilityを無視しています。
（一旦分けて把握することが重要と言いましたが、関連し合っている部分はもちろんあるので難しいところです。）

例として、以下の逐次スケジュールと同形の並列実行を考えます。

$$
\begin{aligned}
S_{1,2} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; R_{2}(X),\; W_{2}(Y) \bigr\rangle \\[4pt]
\end{aligned}
$$

もちろんConflict Serializableですが、2PLの定義では、ロックの取得・解放の順序しか登場しないため、以下のようなパターンが考えられます。

1. $T_{1}$がGrowing Phaseにロックを取り$X$を更新
2. $T_{1}$がShrinking Phaseに入りロックを解放
3. $T_{2}$がその新しい$X$を読み取る（ロックが解放されているため可能）
4. その後$T_{1}$がAbort
5. $T_{2}$が読み取った$X$は元の値にロールバックされる

![](/images/dbms-isolation/tx012.png)

$T_{2}$ロールバックされた値を読んでいるため、Abortしなければ整合性が保てないと考えられます。
さらに、$T_{2}$をAbortすると、その処理に依存する更に後続のトランザクションも**連鎖的にAbortする必要**が生じます。
この減少を**Cascading Abort**と言いますが、できれば回避したい事態です。

## Strict Two-Phase Lock

CascadingAbortを防ぐには、2PLに、**ロックはトランザクション終了時まで解放しない**、というもう一段の制約を加えます。
これを**Strict Two-Phase Lock**と言います。

![](/images/dbms-isolation/tx013.png)

この制約を設けることで、将来Abortされるかもしれない値は実際に完了(Commit/Abort)されるまで他から読み取られることがないため、CascadingAbortの問題を防ぐことができます。

![](/images/dbms-isolation/tx014.png)

現実の実装ではそもそも「いつロックを解放し始めるか」を一般化して決定しづらいため、トランザクション完了時までロックを保持することで2PLを満たし、結果としてStrict 2PLになっているということも多いはずです。

また細かくは、排他ロックに関してだけ完了時の解放の制約を求めるものをStrict 2PL、全てのロックに関して求めるものをStrong(Rigorous) Strict 2PLと言ったりします。

# ANSI SQL-92 Isolation Level

少し話が変わって、Conflict Serializabilityをはじめとして、これまでに登場した概念は馴染みのないもの多いのではないでしょうか。
トランザクションのについて学ぼうとすると、**Read Commited**や**Repeatable Read**といった分離レベル、あるいは**Dirty Read**や**Phantom Read**といった現象に遭遇するはずです。

これはANSI（米国国家標準協会）が1992年に定めたSQLに関する規格、**SQL-92**を由来とします。
世間的にも広く流布している概念ですが、これをそのまま鵜呑みにしてしまうのはいくつかの点で注意が必要です。
まずは、簡単に定義を確認しておきます。

## 定義

**SQL-92 Isolation Level**では3つのSerializabilityに反する**Phenomenon/Anomaly**を定義しています。

| Phenomenon | Name             | Description                                                                    |
| ---------- | ---------------- | ------------------------------------------------------------------------------ |
| **P1**     | **Dirty Read**   | 未コミットの他のトランザクションの値を読んでしまう                             |
| **P2**     | **Fuzzy Read**   | 複数回同じ値を読むと、コミット済みの他のトランザクションにより、結果が変わる   |
| **P3**     | **Phantom Read** | 複数回範囲検索をすると、コミット済みの他のトランザクションにより、結果が変わる |

そして、これらに対応する形でどこまで防ぐかで、**Isolation Level**が定義されています。

| Isolation Level      | 防ぐPhenomenon/Anomaly |
| -------------------- | ---------------------- |
| **Read Uncommitted** | なし                   |
| **Read Committed**   | P1                     |
| **Repeatable Read**  | P1・P2                 |
| **Serializable**     | P1・P2・P3             |

これらは包含関係になっており、上位のIsolation Levelになれば下位のLevelで防ぐAnomalyも防ぎます。

![](/images/dbms-isolation/tx015.png)

## Conflict Serializableとの関係

では、Conflict Serializable（かつCascading Abortを避ける）スケジュールは、この定義におけるどこに位置するでしょうか。

- Dirty Readは、CascadingAbortによって防がれます。
- Fuzzy Readに関しても、Conflict Serializabilityによって防がれます。
- ところが、Phantom Readは、範囲に対する競合制御なければ防げません。

ということは、**ANSIの定義上は、Repeatable Read相当**ということになります。
この点は事をややこしくする一つです。

## Snapshot Isolationとの関係

先出しになりますが、現代のRDBMSは多くが、**MVCC**（Multi-Version Concurrency Control）と言う方法を用い、**Snapshot Isolation**という別の基準を実現しています。
Snapshot Isolation自体が、『A Critique of ANSI SQL Isolation Levels』という、ANSIのIsolation Levelのアンチテーゼの論文を由来としています。
そういった歴史的背景からも、先ほどのベン図の中には綺麗に収まらない概念です。

- Snapshot IsolationはPhantom Readを防ぐ
  - ANSIの定義上はSerializableとも言える
- しかし、**Write Skew**という別のAnomalyを引き起こす
  - Write Skewは病院の当直の例が有名です
- 一方で、Write Skewは前述のS2PLを取っている場合は発生しない

![](/images/dbms-isolation/tx016.png)

この点は更に事をややこしくしています。
私たちが普段接するRDBMSである、MySQLやPostgreSQLやOracleなどはMVCCを実装していますが、ANSIの定義とは相容れない概念にも関わらず、Isolation LevelとしてSQL-92の用語を使っています。
よく耳にする「MySQLはRepeatable ReadでもPhantom Readを防ぐ」といった矛盾もうこういった背景があります。

# Snapshot Isolation

では、少々前後してしまいましたが、**Snapshot Isolation**とは何でしょうか。
定義としては以下のようになっています。

1. トランザクション開始時に、それまでにコミットされた最後の値をスナップショットと考え、以降の読取りは常にその値を読む
2. 以降の他トランザクションがコミットした値に関して、書き込みが競合した場合はAbortする

読み込みは全て開始当時の情報を使うので以後の書き込みと競合せず、実装時にも**共有ロックを取る必要が生じません**。
そのため、2PLで弱点だったロック待ちやDeadlockが発生しやすいという問題が緩和されています。
（Writed-Writeは競合するため、引き続きロックが必要です。）

# MVCC （Multi-Version Concurrency Control）

最後にSnapshot Isolationをどう実装するかを駆け足で見ていきます。
有名な方法は**MVCC**（Multi-Version Concurrency Control）です。
これは、スナップショットを実現するために、同じデータ項目に関して複数のバージョン保存する実装を取ります。

## 行（Tuple）

一般的なRDBMSでは「テーブルの行（Tuple）」が最小の更新単位です。
MVCCでは、行を保存するデータ内に**2 つのトランザクション識別子** を追加します。

|          | 意味                                                           |
| -------- | -------------------------------------------------------------- |
| `tx_min` | **行を挿入した**トランザクション識別子                         |
| `tx_max` | **行を論理削除した**トランザクション識別子（**初期値はNULL**） |

## DML

| 操作   | 変更点                                      | ロック       |
| ------ | ------------------------------------------- | ------------ |
| INSERT | `tx_min ← 自 TX`, `tx_max ← NULL`           | なし         |
| UPDATE | 旧行: `tx_max ← 自 TX`、新行: INSERT と同じ | Write ロック |
| DELETE | 旧行: UPDATEと同じ                          | Write ロック |

- UPDATEは「古いバージョンを論理削除 → 新バージョンを挿入」の 2 ステップ。
- Writeロックはコミットまで保持し、他 TX からの同時書込みを防ぎます。

## 可視性ルール

各トランザクションは **開始時点のスナップショット**（コミット状態＋未確定 TX 一覧）を持ちます。  
行をスキャンするときは以下を両方満たすバージョンのみ可視と判定します。

1. `tx_min` が **自スナップショット時点以前** かつ **コミット済み**
2. `tx_max` が **NULL** または “スナップショット時点で未コミット”

## 書込み競合とAbort

1. 書込み対象行にWriteロックを取得を試みる
2. 以降の他トランザクションが書き込みを行なっていればロック待ちとなる
3. 他のトランザクションが完了（Commit or Abort）すると、ロックが解除される
4. tx_maxがトランザクション開始時に完了していないIDの場合
   - Commit済みなら、自身をAbort
   - Abort済みなら処理を進める

## Serializable Snapshot Isolation

- Snapshot IsolationはWrite Skewの問題がある
- これを解決する、Serializable Snapshot Isolation、が現代では定義され、PostgreSQLはこれを実装している。

# おわりに

さて、Snapshot IsolationやMVCC周りは筆者の知識も十分とは言えずだいぶ駆け足になってしまいましたが、とりあえずIsolationの基礎は一通り話せたつもりです。
もちろんこれは重厚なトランザクション理論の入り口に立ったに過ぎませんが、以前よりも雰囲気でトランザクションを理解している度が少しだけ減った気がします。
自作RDBMSといった酔狂な試みだけでなく、実務的にも普段触るMySQLやPostgreSQLのトランザクションの挙動を推測しやすくなるのではないでしょうか。

さて、今回はIsolationのみに着目しましたが、まだDurability、途中で障害が起きた時にも不整合が起きないようにする仕組みについてはほとんど触れてきませんでした。
元気があれば、いつになるかわかりませんが、後編の記事を書こうと思います。
