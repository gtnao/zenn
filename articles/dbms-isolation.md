---
title: "DBMSを自作するために必要なトランザクション知識（Isolation編）"
emoji: "🐘"
type: "tech"
topics: ["database", "db", "rdbms", "transaction"]
published: false
publication_name: "primenumber"
---

# はじめに

本記事は、自作DBMSを趣味とする筆者が、トランザクション周りの実装を進めるにあたって、自身の中で腹落ちするために調べた内容を記事化したものです。
人類が生み出したソフトウェアの叡智の結晶の1つであるDBMS、その根幹に鎮座するトランザクション理論は、ユーザー視点での「あって当たり前」という感覚とは裏腹に、様々な概念や歴史的な背景が入り乱れ、全体を把握することが大変困難です。
従って、本記事に至っても、筆者の理解不足が含まれている可能性はありますので、ぜひお手柔らかにご指摘ください。

# トランザクションとは

データベースにおけるトランザクションとは、一言で言うと「一連の読み書き操作をまとめたもの」です。
耳タコな例である銀行の送金処理については今更説明しませんが、一連の操作が「全て成功する」か「全て失敗する」かのどちらかであることを求められるケースは多く、これがトランザクションという概念が必要になる動機です。

ただし、どのような操作をまとめるかはアプリケーション側の責務であり、DBMS側はそれらがビジネスロジック上どのような意味を持つかには関与しません。
DBMSはあくまで一般的なトランザクションというまとまりに対して必要されるいくつかの特性を保証することを責務とします。

# ACID

トランザクションが保証すべき性質として、ACID特性が広く知られているのでご存知かと思います。

- Atomicity (原子性)
- Consistency (一貫性)
- Isolation (独立性/隔離性)
- Durability (永続性)

しかし、各特性の定義はかなり曖昧で、単に「ACID特性を保証する」とだけ言っても、大した情報量がありません。

特にイケてないのは Consistency です。
これは例えば「口座残高がマイナスにならない」「ユーザーIDは重複しない」といった、ビジネスロジックの整合性を保証するとされていますが、具体的にどういった整合性を要求するのはアプリケーション側の責務です。
DBMSの提供する型システムや制約はConsistencyを支援しますが、汎用的なトランザクション処理からしたらその具体は知ったこっちゃないわけです。
かの有名な『データ指向アプリケーションデザイン』でも、ACIDはほとんどマーケティング用語で、特にConcistencyはACIDに含まれないと、散々に言われてしまっています。

残りの Atomicity、Isolation、Durability は、DBMS側が保証すべき特性です。
これらは相互に関連していますが、各々どういった概念・理論の元で成り立っているかを分けて考えることで、トランザクションの全体像を捉えやすくなると思っています。

## Atomicity

Atomicityは、前述の「全て成功する」か「全て失敗する」かを保証する性質です。
もしトランザクションが完了できなかった場合（Abort）、トランザクション開始前の状態にデータベースを戻す必要があります。
実現方法としては、トランザクション中に行った変更操作を記録しておき、Abort時にそれらを逆順に実行して元に戻す、というものが考えられます。
Durabilityを考えるともう少しややこしくなりますが、本記事ではこの程度に留めておきます。

注意点は、Atomicity自体は単一のトランザクション内で完結する性質であり、複数のトランザクションが同時に実行される状況を直接扱うものではありません。それはIsolationの役割です。
やはり分けて捉えることが重要です。

## Durability

Durabilityは、ひとたびCommitされたトランザクションによる変更は、その後障害などが発生しても失われないことを保証する性質です。
もちろん、隕石が落ちてきたらどうしようもないので、トランザクションの文脈では、変更内容が不揮発性ストレージ（ディスクやSSDなど）に記録された時点でDurabilityが保証されると考えます（単一DBの場合）。

最も単純な実現方法は、Commitされるたびにその内容をディスクに書き込むことに思えます。
しかし、ディスクアクセスはメモリアクセスに比べてすこぶる遅いため、現実的ではないのは自明です。
そのため、実際のDBMSでは、メモリ（バッファプール）上でデータの読み書きを行いますが、揮発性メモリを使うトレードオフとして復旧のためのアルゴリズムが要求されます。
WAL（Write Ahead Log）やARIESという仕組み・アルゴリズムが典型的ですが、本記事では次のIsolationに焦点を当てるのでこちらもこの程度に留めておきます。

## Isolation

Isolationは、複数のトランザクションが同時に実行される状況において互いに影響を与えないことを保証する性質です。
DBMS側で制御して同時に実行されているトランザクションが常に一つになるように他のトランザクションを待たせておけば（逐次実行）、少なくともIsolationの問題は発生しませんが、これまた現実的ではないことは自明です。
そこで、通常は複数のトランザクションを並行(Concurrent)に実行し、各トランザクションの個々の操作は時系列的に入り混じることになります。
しかし、どのような順序でも許容されるならそもそもIsolationという性質が必要にならないため、どのような場合ならOKでNGなのかということが今後の話の中心となります。

# Serializability

## 題材

今後の話を進めるにあたって、例があった方が分かりやすいので、ある2つのトランザクションを考えます。

$$
\begin{aligned}
T_{1} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle\\[4pt]
T_{2} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

$R_i(X)$ は トランザクション $T_i$ がデータ項目 $X$ を読み取る (Read) 操作,
$W_i(X)$ は 同じく $T_i$ が $X$ に書き込む (Write) 操作を表す。
添字 $i$ はその操作を実行するトランザクション番号，括弧内の $X$ は対象データ項目を示す。

## スケジュール

あるトランザクションの集合に対して、その操作を（各トランザクション内での順序を保ったまま）並び替えた列をスケジュールと定義します。

例えば、題材のトランザクションだと、以下のようなスケジュールが考えられます。
（これ以外にも沢山あります。）

$$
\begin{aligned}
S'  &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{2}(Y),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle \\[4pt]
S'' &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

逐次実行の場合のスケジュールは以下のようになります。

$$
\begin{aligned}
S_{1,2} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; R_{2}(X),\; W_{2}(Y) \bigr\rangle \\[4pt]
S_{2,1} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

では本題に戻ります。
ここで、ある並行実行のスケジュールが与えられたとき、「**何らかの基準においては**、少なくともいずれか一つの逐次実行のスケジュールと等価」と言える基準があるとします。
その場合、**その基準の枠内においては**、その並行実行のスケジュールは、Isolationが保証されていると考えることができそうです。

少し展開が飛躍してしまいますが、広く用いられているConflict Serializabilityという基準について考えていきます。

## Conflict Serializability

Conflict Serializabilityは、「競合する操作の実行順序」に注目する考え方です。

### Conflict

まず、Conflict（競合）する操作、を定義します。
以下の3つの条件を全て満たす場合、異なる2つのトランザクション$T_i$と$T_j$にそれぞれ属する操作$op_i$と$op_j$はConflictすると考えます。

1.  $T_i \neq T_j$ （異なるトランザクションである）
2.  $op_i$ と $op_j$ が同じデータ項目にアクセスする
3.  $op_i$ と $op_j$ の少なくとも一方がWrite操作である

具体的には、以下のペアがConflictします（$X$は同じデータ項目）。

- $R_i(X)$ と $W_j(X)$ （Read-Write Conflict）
- $W_i(X)$ と $R_j(X)$ （Write-Read Conflict）
- $W_i(X)$ と $W_j(X)$ （Write-Write Conflict）

Read操作同士 ($R_i(X)$ と $R_j(X)$) は、Conflictしません。

ちなみに、Conflictする操作のペアが存在すること自体が即座に問題なわけではなく、またこの時点では順序関係はなくただのペア関係という点を念頭においてください。

先ほどから用いている題材の場合、

$$
\bigl\{\, \{W_{1}(X),\,R_{2}(X)\},\; \{W_{1}(Y),\,W_{2}(Y)\} \,\bigr\}
$$

というConflictが存在します。

### Conflict Equivalence

さて、あるスケジュールが与えられると、先ほどの定義で導出したConflictする操作のペアに順序関係が生まれます。

例として、先ほどの$S'$スケジュールを考えてみます。

$$
\begin{aligned}
S'  &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{2}(Y),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

こちらのスケジュールでは、Conflictする操作は以下のような順序関係になります。

$$
\bigl\{\, (R_{2}(X) \;\to\; W_{1}(X)),\; (W_{2}(Y) \;\to\; W_{1}(Y)) \,\bigr\}
$$

そして、以下の$T_{2}$, $T_{1}$の順序で逐次実行したスケジュールに関するConflictの順序関係も同様になります。

$$
\begin{aligned}
S_{2,1} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

ある異なるスケジュール間のConflictの順序関係が一致する場合、それらのスケジュールはConflict Equivalentであると言えます。
さらに、あるスケジュールがいずれかの逐次実行のスケジュールとConflict Equivalentである場合、そのスケジュールはConflict Serializableと言うことができます。

### Conflict Serializableではない例

先ほどの例における$S'$はConflict Serializableでしたが、$S''$はConflict Serializableとは言えません。

$$
\begin{aligned}
S'' &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

Conflictの順序を考えると以下のようになります。

$$
\bigl\{\, (R_{2}(X) \;\to\; W_{1}(X)),\; (W_{1}(Y) \;\to\; W_{2}(Y)) \,\bigr\}
$$

そして、こちらをトランザクション間の順序に当てはめると以下のようになります。

$$
T_{2} \;\rightarrow\; T_{1}, \qquad
T_{1} \;\rightarrow\; T_{2}
$$

ある$T_{1}$に属する操作はある$T_{2}$に属する操作より前に行われるが、別の$T_{1}$に属する操作はある$T_{2}$に属する操作より後に行われるということになります。
これを満たす逐次実行のConflict順序が存在しないことも直感的に想像が着くと思います。

# 実装方法

ここまでで、ある並行実行がIsolationを保証していると言える基準は導くことができました。
しかしながら、現実にはDBMSにはリアルタイムにトランザクションが流れてきますし、それらはCommit/Abortされるまでどのような操作が行われるかも分かりません。
このような条件下において、結果的にConflict Serializabilityが満たされている状態を実現するにはどうすればいいかを考えなければいけません。

## Shared/Exclusive Lock

## Two Phase Lock

## Deadlock

## Cascading Abort

## Strict Two Phase Lock

# ANSI SQL-92 Isolation Level
