---
title: "自作DBMSに必要な体系的トランザクション知識（導入・Isolation編）"
emoji: "🐘"
type: "tech"
topics: ["database", "db", "rdbms", "transaction"]
published: false
publication_name: "primenumber"
---

# はじめに

本記事は、**自作DBMS**を趣味とする筆者が、トランザクション周りの実装を進めるにあたって、自身の中で腹落ちさせるために調べた内容を記事化したものです。
そういった動機が故に、多少長いですが、**頭から読み進めていくこと**で、（この記事に辿り着く方であればご存知の基礎的な話を除いて、）自然な思考の流れで理解が進むように心がけたつもりではあります。

人類が生み出したソフトウェアの叡智の結晶の1つであるDBMS、その根幹に鎮座する**トランザクション理論**は、ユーザー視点での「あって当たり前」という感覚とは裏腹に、様々な概念や歴史的な背景が入り乱れ、全体像を把握することは大変困難です。
従って、本記事に至っても、筆者の理解不足が含まれている可能性はあり、その際はお手柔らかにご指摘ください。

ちなみに、自作と名を打ってますが、ソースコードは一切登場しません。

# トランザクションとは

データベースにおけるトランザクションとは、一言で言うと**一連の読み書き操作をまとめたもの**です。
耳タコな例の銀行の送金処理については今更説明しませんが、一連の操作が**全て成功するか、全て失敗するか**のどちらかであることが求められるケースは現実的にも多く、これがトランザクションという概念が必要になる基本的な動機です。

ただし、具体的にどのような操作をまとめるかはアプリケーション側の責務であり、DBMS側はそれらがビジネスロジック上どのような意味を持つかには関与しません。
DBMSはあくまで、一般的なトランザクションというまとまりに対して要求されるいくつかの抽象的な特性を保証することを責務とします。

# ACID

トランザクションが保証すべき性質として、**ACID**特性が広く知られています。
その概要は今更解説する必要はないかもしれませんが、幾分注意が必要です。

- **Atomicity** （原子性）
- **Consistency** （一貫性）
- **Isolation** （独立性/隔離性）
- **Durability** （永続性）

特にイケてないのはConsistencyです。
これは例えば、「口座残高がマイナスにならない」、「ユーザーIDは重複しない」といった、ビジネスロジックの整合性を保証する性質とされていますが、具体的にどういった整合性を要求するかはアプリケーション側の責務です。
DBMSの提供する型システムや制約はConsistencyを間接的に支援するかもしれませんが、汎用的なトランザクション処理からしたらその具体は知ったこっちゃないわけです。
かの有名な『データ指向アプリケーションデザイン』でも

> ACIDはほとんどマーケティング用語

> 特にConcistencyはACIDに含まれない

などと、散々に言われてしまっています。

残りの**Atomicity**、**Isolation**、**Durability**は、DBMS側が保証すべき特性です。
これらはもちろん相互に関連し合っているものの、各々どういった保証でどういった理論の元で成り立っているのかを**分解して考える**ことで、トランザクション理論の全体像を捉えやすくなると筆者は考えています。

## Atomicity （原始性）

**Atomicity**は、前述の**全て成功するか全て失敗するか**を保証する性質です。
もしトランザクションが完了できなかった場合（Abort）、トランザクション開始前の状態にデータベースを戻す必要があります。

実現方法としては、トランザクション中に行った変更操作を記録しておき、Abort時にそれらを逆順に実行して元に戻す、という方法が考えられます。
Durabilityを考える（ディスクに未書き込みなCommitすべき操作や、書き込み済みのAbortすべき操作が存在）ともう少しややこしくなるのですが、本記事ではこの程度に留めておきます。

注意点は、Atomicity自体は**単一のトランザクション内で完結**する性質であり、複数のトランザクションが同時に実行される状況を直接扱うものではありません。
それはIsolationの役割です。
やはり分けて捉えることが重要です。

## Durability （永続性）

**Durability**は、ひとたびCommitされたトランザクションによる変更は、後に**障害などが発生しても失われない**ことを保証する性質です。
もちろん、隕石が落ちてきたらどうしようもないので、トランザクション文脈では、変更内容が不揮発性ストレージ（ディスクやSSDなど）に何らかの形で記録された時点でDurabilityが保証されるとして考えることが多いはずです（単一DBの場合）。

最も単純な実現方法は、Commitされるたびにその内容をディスクに書き込むことに思われます。
しかし、ディスクアクセスはメモリアクセスに比べてすこぶる低速なため、現実的ではないのは見るも明らかです。
そのため、現実のDBMSでは、メモリ（バッファプール）上でデータの読み書きを行いますが、揮発性メモリを使うトレードオフとして**復旧のためのアルゴリズム**が要求されます。
**WAL（Write-Ahead Log）**や**ARIES**という仕組み・アルゴリズムが典型的ですが、本記事では次のIsolationに焦点を当てるため、こちらもこの程度に留めておきます。

## Isolation （独立性/隔離性）

**Isolation**は、**複数のトランザクションが同時に実行される状況において互いに影響を与えない**ことを保証する性質です。

DBMS側で制御し、同時に実行されているトランザクションが常に一つになるように他のトランザクションを待たせておけば（**逐次実行**と言う）、少なくともIsolationの問題は発生しませんが、これまたパフォーマンス上現実的ではないことは明白です。

そこで、通常は複数のトランザクションを並行（Concurrent）に実行し、各トランザクションの個々の操作は時系列的に入り混じることになります。
しかし、デタラメでいいはずもないので、**どのような順序なら許容範囲**なのか、**部分的に許容される**のか、ということが今後の話のテーマとなります。

# Serializability

## 題材

今後の話を進めるにあたって、例があった方が分かりやすいので、ある2つのトランザクションを考えます。

$$
\begin{aligned}
T_{1} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle\\[4pt]
T_{2} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

- $R_i(X)$はトランザクション$T_i$がデータ項目$X$を読み取る（Read）操作
- $W_i(X)$は同じく$T_i$が$X$に書き込む（Write）操作
- 添字$i$はその操作を実行するトランザクション番号,括弧内の$X$は対象データ項目

![](/images/dbms-isolation/tx001.png)
![](/images/dbms-isolation/tx002.png)

## スケジュール

あるトランザクションの集合に対して、それらに含まれる全ての操作の集合を（各トランザクション内での順序を保ったまま）並び替えた列をスケジュールと定義します。

題材のトランザクション集合だと、以下のような並行スケジュールが考えられます。
（これ以外にも沢山あります。）

$$
\begin{aligned}
S'  &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{2}(Y),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle \\[4pt]
\end{aligned}
$$

![](/images/dbms-isolation/tx003.png)

---

$$
\begin{aligned}
S'' &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

![](/images/dbms-isolation/tx004.png)

逐次実行の場合は、それぞれ以下のようになります。

$$
\begin{aligned}
S_{1,2} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; R_{2}(X),\; W_{2}(Y) \bigr\rangle \\[4pt]
\end{aligned}
$$

![](/images/dbms-isolation/tx005.png)

---

$$
\begin{aligned}
S_{2,1} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

![](/images/dbms-isolation/tx006.png)

ある並行実行のスケジュールが与えられたとき、「**何らかの基準においては**、少なくともいずれか一つの逐次実行のスケジュールと等価」と言える基準があるとします。
その場合、**その基準の枠内においては**、その並行実行は、**Isolationが部分的に保証**されていると考えることができそうです。

ここは、少し展開が飛躍してしまいますが、広く用いられている**Conflict Serializability**という基準について考えていきます。

## Conflict Serializability

**Conflict Serializability**は、**競合する操作の処理順序**に注目する考え方です。

### Conflict

まず、**Conflict**（競合）する操作、を定義します。
以下の3つの条件を全て満たす場合、異なる2つのトランザクション$T_i$と$T_j$にそれぞれ属する操作$op_i$と$op_j$はConflictすると考えます。

1.  $T_i \neq T_j$ （異なるトランザクションである）
2.  $op_i$ と $op_j$ が同じデータ項目にアクセスする
3.  $op_i$ と $op_j$ の少なくとも一方がWrite操作である

具体的には、以下のペアがConflictします（$X$は同じデータ項目）。

- $R_i(X)$ と $W_j(X)$ （Read-Write Conflict）
- $W_i(X)$ と $R_j(X)$ （Write-Read Conflict）
- $W_i(X)$ と $W_j(X)$ （Write-Write Conflict）

Read操作同士、$R_i(X)$ と $R_j(X)$は、Conflictしません。

ちなみに、Conflictする操作のペアが存在すること自体が即座に問題なわけではなく、またこの時点では順序関係はなく**ただのペア関係**という点を念頭においてください。

先ほどから用いている題材の場合は、以下の二つのConflictが存在します。

$$
\bigl\{\, \{W_{1}(X),\,R_{2}(X)\},\; \{W_{1}(Y),\,W_{2}(Y)\} \,\bigr\}
$$

![](/images/dbms-isolation/tx007.png)

### Conflict Equivalence

あるスケジュールが与えられると、先ほどの定義で導出したConflictする操作のペア群に順序関係が生まれます。

例として、先ほどの$S'$スケジュールを考えてみます。

$$
\begin{aligned}
S'  &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{2}(Y),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

こちらのスケジュールでは、Conflictする操作のペアは以下のような順序関係となります。

$$
\bigl\{\, (R_{2}(X) \;\to\; W_{1}(X)),\; (W_{2}(Y) \;\to\; W_{1}(Y)) \,\bigr\}
$$

![](/images/dbms-isolation/tx008.png)

そして、以下の$T_{2}$, $T_{1}$の順序で逐次実行したスケジュールに関するConflictの順序関係も同様となります。

$$
\begin{aligned}
S_{2,1} &= \bigl\langle\, R_{2}(X),\; W_{2}(Y),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y) \bigr\rangle
\end{aligned}
$$

![](/images/dbms-isolation/tx009.png)

ある異なるスケジュール間のConflictの順序関係が全て一致する場合、それらのスケジュールは**Conflict Equivalent**であると言えます。
さらに、あるスケジュールがいずれかの逐次実行のスケジュールとConflict Equivalentである場合、そのスケジュールは**Conflict Serializable**と言うことができます。

### Conflict Serializableではない例

先ほどの例における$S'$はConflict Serializableを満たしましたが、$S''$はそうとは限りません。

$$
\begin{aligned}
S'' &= \bigl\langle\, R_{2}(X),\; R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; W_{2}(Y) \bigr\rangle
\end{aligned}
$$

Conflictの順序を考えると以下のようになります。

$$
\bigl\{\, (R_{2}(X) \;\to\; W_{1}(X)),\; (W_{1}(Y) \;\to\; W_{2}(Y)) \,\bigr\}
$$

![](/images/dbms-isolation/tx010.png)

こちらを属するトランザクション間の順序に当てはめると、以下のようになります。

$$
T_{2} \;\rightarrow\; T_{1}, \qquad
T_{1} \;\rightarrow\; T_{2}
$$

ある$T_{1}$に属する操作はある$T_{2}$に属する操作より前に行われるが、別の$T_{1}$に属する操作はある$T_{2}$に属する操作より後に行われるということになります。
これを満たす逐次実行のConflict順序が存在しないことも直感的に想像が着くと思います。

# 実装方法

ここまでで、ある並行実行が許容されるか否かの判断軸（Conflict Serializability）を手に入れましたが、その許容される並行実行を実現するにはどうすればいいでしょうか。
現実のDBMSでは、トランザクションはリアルタイムに流れ込み、完了（Commit/Abort）されるまでどのような操作が行われるかも分かりません。
そうなると、「あとから見ればConflict Serializableだった」という結果を、**実行中から保証**するための仕組みが必要になってきます。

そこで登場するのがロック機構、古典的な**Two-Phase Lock**（2PL）です。
またまた展開が飛躍してしまいますが、2PLに従った結果得られるスケジュールは必ずConflict Serializableになる、という定理が知られています。

## Shared/Exclusive Lock

まずロックの基本形を確認します。

|                      | Shared Lockを保持中 | Exclusive Lockを保持中 |
| -------------------- | ------------------- | ---------------------- |
| Shared Lockを取得    | OK（取得可）        | NG（待機）             |
| Exclusive Lockを取得 | NG（待機）          | NG（待機）             |

- **Shared Lock**（共有ロック）: 読み取り時に取得。互いに共有可。
- **Exclusive Lock**（排他ロック）: 書き込み時に取得。他のロックと競合。
- 競合した場合は、ロックが解放されるまで待機する。

この辺りは馴染みもあるかと思います。Conflictの定義とも似ていますね。

## Two Phase Lock

2PLはロックの**取得・解放を二段階の順序**で行われるようにさらに厳格にします。
簡単に言えば、ロックを**解放し始めたら取得してはいけないと**いう制約です。

1. **Growing Phase**（成長期）: ロックを取得してよい（解放は禁止）
2. **Shrinking Phase**（縮小期）: ロックを解放してよい（取得は禁止）

横軸を時間軸、縦軸を一つのトランザクションにおけるロックの取得件数とすると以下のようになります。

![](/images/dbms-isolation/tx011.png)

### 証明

「2PL に従った結果得られるスケジュールは必ずConflict Serializableになる」という命題は背理法で証明できます。

1. 2PL を守るトランザクション集合のスケジュール $S$ が **Conflict Serializable でない**  
   と仮定する。
2. 非 Serializable なら **トランザクション競合グラフ** にサイクルが存在する。
3. サイクルの 2 頂点 $(T_i,T_j)$ を結ぶ辺は、あるデータ項目 $X$ について  
   $T_i$ が先にロックを取得し解放、次に $T_j$ がロックを取得したことを示す。
4. 逆向きの辺では $T_j$ が先にロックを取得し解放、あとで $T_i$ が取得している。
5. すると $T_i$ は **解放後に再びロックを取得** したことになり、  
   2PL の「縮小期に取得禁止」に違反して矛盾する。

といった要領です。

### Deadlock

2PLは厳格なロック制御のおかげで整合性は保てるものの、その分**デッドロックが発生しやすい**という弱点があります。
デッドロック自体の説明はよく聞くと思うので割愛しますが、 潜在的に起こる以上は検知の仕組みと発生時の対応の決めが必要です。
それに関しても本稿では省略します。

# Cascading Abort

さて、2PLを課せば、ある基準においてはIsolation特性を許容できる並行実行制御を実現できそうです。
しかし、ここまでの話では、トランザクションが**Abortされることを考えていません**でした。
ACID特性のIsolationだけに着目しており、Atomicity/Durabilityを無視しています。
（一旦分けて把握することが重要と言いましたが、関連し合っている部分はもちろんあるので難しいところです。）

例として、以下の逐次スケジュールと同形の並列実行を考えます。

$$
\begin{aligned}
S_{1,2} &= \bigl\langle\, R_{1}(X),\; W_{1}(X),\; W_{1}(Y),\; R_{2}(X),\; W_{2}(Y) \bigr\rangle \\[4pt]
\end{aligned}
$$

もちろんConflict Serializableですが、2PLの定義では、ロックの取得・解放の順序しか登場しないため、以下のようなパターンが考えられます。

1. $T_{1}$がGrowing Phaseにロックを取り$X$を更新
2. $T_{1}$がShrinking Phaseに入りロックを解放
3. $T_{2}$がその新しい$X$を読み取る（ロックが解放されているため可能）
4. その後$T_{1}$がAbort
5. $T_{2}$が読み取った$X$は元の値にロールバックされる

![](/images/dbms-isolation/tx012.png)

$T_{2}$ロールバックされた値を読んでいるため、Abortしなければ整合性が保てないと考えられます。
さらに、$T_{2}$をAbortすると、その処理に依存する更に後続のトランザクションも**連鎖的にAbortする必要**が生じます。
この減少を**Cascading Abort**と言いますが、できれば回避したい事態です。

## Strict Two-Phase Lock

CascadingAbortを防ぐには、2PLに、**ロックはトランザクション終了時まで解放しない**、というもう一段の制約を加えます。
これを**Strict Two-Phase Lock**と言います。

![](/images/dbms-isolation/tx013.png)

この制約を設けることで、将来Abortされるかもしれない値は実際に完了(Commit/Abort)されるまで他から読み取られることがないため、CascadingAbortの問題を防ぐことができます。

![](/images/dbms-isolation/tx014.png)

現実の実装ではそもそも「いつロックを解放し始めるか」を一般化して決定しづらいため、トランザクション完了時までロックを保持することで2PLを満たし、結果としてStrict 2PLになっているということも多いはずです。

また細かくは、排他ロックに関してだけ完了時の解放の制約を求めるものをStrict 2PL、全てのロックに関して求めるものをStrong(Rigorous) Strict 2PLと言ったりします。

# ANSI SQL-92 Isolation Level

さて、ここまででConflict SerializableかつCascading Abortを避けることができるスケジュールのIsolationは実装できそうです。
一方で、どちらも馴染みのないものではあります。
よく聞くところだと、RepeatableReadやReadCommitedといったような分離レベルやDirtyReadやNonRepeatableReadといった単語ではないでしょうか。
これはANSIがまとめたSQL-92における分離レベルです。

これをそのまま鵜呑みにしてしまうのは注意が必要なのですが、簡単に定義を確認しておきます。

## 定義

3つのSerializabilityに反するPhenomenon/Anomalyが定義されています。

- P1: Direty Read
- P2: Non-Repeatable Read
- P3: Phantom Read

これを防ぐものとして、それぞれ

- Read Uncommited: どれも防がない
- Read Commited: Dirty Readを防ぐ
- Repeatable Read: Non-Repeatable Readを防ぐ
- Serializable: Phantom Readを防ぐ

これらは包含関係になっており、下に行くほど上で防いでいるPhenomenonも防ぎます。

<ベン図をMermaid>

## Conflict Serializableとの関係性

では、Conflict Serializable（かつCascading Abortを避ける）スケジュールは、この定義におけるどこに位置するでしょうか。

- DirtyReadはCascadingAbortによって防がれます。
- Non-Repeatable Readに関しても、Conflict Serializabilityによって防がれます。
- ところが、Phantom Readは競合するものがないので、この枠組みだと防げません。

そうなってくると、ANSIの定義に従えば、Repeatable Read止まりということになります。
(範囲に対してロックを取るようなことをすればANSI Serializableになります)

この点も事をややこしくする一つです。

## Snapshot Isolationとの関係性

更に極め付けは、現代のRDBMSが多く実装しているMVCCはSnapshot Isolationという別の基準を実装するための方法で、SnapshotIsolationはこのANSIの企画を批判する論文の中で提示されたものです。

そのため、さきほどのベン図の中には含まれなくなっています。
具体的に言うと、Snapshot IsolationはPhantom Readを防ぎますが、WriteSkewというANSIでは提示されていない別のAnomalyを引き起こします。
そして、WriteSkewはS2PLを取っているConflict Serializabilityでは起きません

そのため、ベン図はおかしなことになります。

<ベン図をMermaid>

この点はかなりややこしい上に、私たちが普段接するMySQLやPostgreSQLといったRDBMSはMVCCを使っています。
更に、なぜかベン図が相容れないのにも関わらず、IsolationLevelはANSIの定義を使っています。
各種DBMSの定義が一致していない、という話は結構有名ですが、そういう裏があります。
更に、本稿で触れた理論以外にも俺が考えた最強のDBMSを作るために独自の拡張がされているとも考えられここが難しいです。
それぞれをそのまま理解するのも難しいし、理論から攻めても乖離があると言う感じです。

# Snapshot Isolation

では、Snapshot Isolationとは何でしょうか

定義としては以下のようになっています。

<定義を書く。読み込みのスナップショット。書き込みの競合があったら先がちでAbort>

読み込みは全てその当時の情報を使うので書き込みと競合しないわけです。
そのため、実装時にもロックを取らずに済み、2PLで起こるロック待ちになったりDeadlockが起きやすい問題が緩和しています。
(Writed-Writeは競合するためそうではないです)

# MVCC

さて、最後にSnapshotIsolationをどう実装するかです。
一番知られている実装方法はMVCCです。
Multi Version Concurrency Controlで、Snapshotを実現するために、同じ要素を複数バージョン保存するような実装を取ります。

具体的に見ていきましょう。
一般的なRDBMSにおいて、ある要素とはテーブルの行であると思います。
行はTupleと言われますが、それぞれその値がバイナリ化されて保存されています。
（どのように保存されるか、ページなどの話は今回は省略します。）

MVCCではない場合は、
同一のTupleをReadなりWriteなりする際にロックを取ります。先ほどの話です。
MVCCの場合は、Tupleの先頭に、どのトランザクションで挿入されたかのIDとどのトランザクションで消されたかのIDを持ちます。
PostgreSQLではtx_min, tx_maxというフィールドがMVCCのために存在します。

実際にInsert, Update, Deleteする際の処理を見てみます。

Insertの場合は、tx_minに自身のtx_idをいれ、tx_maxはからです
Updateの場合は、元々のtx_maxに自身のtx_idをいれ削除し、新しいinsertをします
Deleteの場合は、Updateの削除だけ

そして、Scanする際はどうしましょうか
DBMSはどのトランザクションがCommitされAbortされたかを持っているのと、TransactionのIDは単調増加するので順序関係がわかります。
そのため、Snapshotを取るを擬似的に行うために、Scanした際に自身より若くてAbortされてないものだけを読み取るようにします（読み取っていきながら無視する）
さらに自身より若くてコミットされているtx_maxがあればそれは読み取りません。

さらにWriteの制約を守るために、Write時にはロックを取ります（COmmit間で保持します）
そして、ロックが外れたら、tx_maxに入っている値を見ます。
それがAbortされているTransactionの値であればそのまま進めますが、Commitされていればそれはすでに削除されています（あるいは更新されている）
そこで自身もAbortを決め込みます。

# おわりに

次は余裕があったらDurabilityを解説する
WALやARIES
